1. Introduction about the demo:
	This application is a linux user space code, which is a zmk programming example

2. Build instructions:
   
   It is compiled with tool chain as below:
   $ source /home/b32331/mcu/toolchains/fsl-imx-xwayland-glibc-x86_64-fsl-image-gui-cortexa9hf-neon-toolchain-4.1.15-2.0.0/environment-setup-cortexa9hf-neon-poky-linux-gnueabi
   $ make clean
   $ make
   
3. Run instructions:

root@imx6qdlsolo:~/zmk# ./zmk

         ZMK Programming Example

[INFO]   SNVS_HPVIDR1=0x3e0100, SNVS_HPVIDR2=0x0
[INFO]            SNVS_HPVIDR1[IP_ID,MAJOR_REV,MINOR_REV]=[0x3e, 0x1, 0x0]
[INFO]   The current ZMK key value before starting the ZMK algorithm is 0x0
[INFO]   SNVS_HPLR  = 0x0
[INFO]   SNVS_LPLR  = 0x0
[INFO]   A.1. Checking transition SSM (System Security Monitor - see SNVS_HPSR[SSM_ST]) from check state to functional state (trusted/secure/non-secure)
[INFO]           System Security Monitor is in Non-Secure mode
[INFo]   A.2. Set the correct value in the Power Glitch Detector Register.
[INFO]           SNVS_LPPGDR power glitch before init 0x41736166
[INFO]           SNVS_LPPGDR power glitch after init 0x41736166
[INFO]   A.3. Clear the power glitch record in the LP Status Register.
[INFO]           SNVS_LPSR  before init 0x40000000
[INFO]           SNVS_LPSR  after init 0x40000008
[INFO]   B.1. Verify that ZMK_HWP bit is not set - using SNVS_LPMKCR[ZMK_HWP]
[INFO]           SNVS_LPMKCR before check ZMK_HWP 0x0
[INFO]           SNVS_LPMKCR[ZMK_HWP] Zeroizable Master Key hardware Programming mode is not set.
[INFO]   B.2. Verify that ZMK is not locked for write - using SNVS_HPLR, SNVS_LPLR registers
[INFO]           SNVS_HPLR  before checking is 0x0
[INFO]           SNVS_LPLR  before checking is 0x0
[INFO]           SNVS_HPLR[ZMK_WSL,ZMK_RSL,MKS_SL] Zeroizable Master Write, Read, Select Soft Locks fields are not set.
[INFO]           SNVS_LPLR[ZMK_WHL,ZMK_RHL,MKS_HL] Zeroizable Master Write, Read, Select Hard Locks fields are not set.
[INFO]           SNVS_LPLR[MKS_HL] Master Key Select Hard Lock is not set.
[INFO]           SNVS_LPLR[ZMK_RHL] Zeroizable Master Key Read Hard Lock is not set.
[INFO]   B.3. Write key value to the ZMK registers.
[INFO]           The ZMK key value before writing with 0x11223344 is 0x0
[INFO]   B.4. Verify that the correct key value is written.
[SUCCESS]                The new ZMK key value is = 0x11223344 and matches with the user desired value.
[INFO]   B.5. Set SNVS_LPMKCR[ZMK_VAL] bit if the ZMK (or the ZMK XORed with the OTPMK) will be used by CAAM as the master key.
[INFO]           SNVS_LPMKCR  before init 0x0
[INFO]           SNVS_LPMKCR  after init 0x8
[INFO]   B.6 (optional) Set SNVS_LPMKCR[ZMK_ECC_EN] bit to enable ZMK error correction code verification.
         Software can verify that the correct nine bit codeword is generated by reading ZMK_ECC_VALUE field.
[INFO]   B.7 (optional) Block software read accesses to the ZMK registers and ZMK_ECC_VALUE field by setting ZMK Read lock bit.
[INFO]   B.8 (optional) Block software write accesses to the ZMK registers by setting ZMK Write Lock bit.
[INFO]           [SECURITY_CHECK] if SNVS_LPZMKRn is zero'd after ZMK_RHL was set
[INFO]           [PASSED] - SNVS_LPZMKRn is 0x0 and cannot be read by a hacker
[INFO]   B.9. Set SNVS_LPMKCR[MASTER_KEY_SEL] and SNVS_HPCOMR[MKS_EN] bits to select combination of OTPMK and ZMK to be provided to the hardware cryptographic module.
[INFO]           For our example MASTER_KEY_SEL is set as 0b10 - Select zeroizable master key when MKS_EN bit is set.
[INFO]           SNVS_LPMKCR  after init 0x1a
[INFO]           SNVS_HPCOMR  before init 0x80002100
[INFO]           SNVS_HPCOMR  after init 0x80002100
[INFO]   B.10 (optional) Block software write accesses to the MASTER_KEY_SEL field by setting MKS lock bit.


